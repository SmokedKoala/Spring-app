# Spring-app

* ### [Inversion of Control (Инверсия управления)](#inversion-of-control-инверсия-управления)
* ### [Dependency Injection (Внедрение зависимостей)](#dependency-injection-внедрение-зависимостей)
  * ### [Способы](#способы)
  * ### [Внедрение зависимостей из внешнего файла](#внедрение-зависимостей-из-внешнего-файла)
* ### [Scope (Область видимости бинов)](#scope-область-видимости-бинов)
* ### [Bean Lifestyle (Жизненный цикл бина)](#bean-lifestyle-жизненный-цикл-бина)
* ### [Spring-аннотации](#spring-аннотации)

Inversion of Control (Инверсия управления)
==========================================
Принцип объектно-ориентированного программирования, 
используемый для уменьшения зацепления (связанности) в компьютерных программах. 
Также архитектурное решение интеграции, упрощающее расширение возможностей системы, 
при котором поток управления программы контролируется фреймворком.

В обычной программе программист сам решает, в какой последовательности делать вызовы процедур. 
Но, если используется фреймворк, программист может разместить свой код в определенных точках выполнения 
(используя callback или другие механизмы), затем запустить «главную функцию» фреймворка, 
которая обеспечит все выполнение и вызовет код программиста тогда, когда это будет необходимо. 
Как следствие, происходит утеря контроля над выполнением кода — это и называется инверсией управления 
(фреймворк управляет кодом программиста, а не программист управляет фреймворком).

Dependency Injection (Внедрение зависимостей)
=============================================
Работа фреймворка, обеспечивающая внедрение зависимости, 
описывается следующим образом. 
Приложение, независимо от оформления, 
исполняется внутри контейнера IoC, предоставляемого фреймворком. 
Часть объектов в программе по-прежнему создается обычным способом языка программирования, 
часть создается контейнером на основе предоставленной ему конфигурации.

Условно, если объекту нужно получить доступ к определенному сервису, 
объект берет на себя обязанность по доступу к этому сервису: 
он или получает прямую ссылку на местонахождение сервиса, 
или обращается к известному «сервис-локатору» и запрашивает ссылку на реализацию определенного типа сервиса. 
Используя же внедрение зависимости, объект просто предоставляет свойство, которое в состоянии хранить ссылку на нужный тип сервиса; 
и когда объект создается, ссылка на реализацию нужного типа сервиса автоматически вставляется в это свойство (поле), используя средства среды.

## Способы:

* ### конструктор:
    с помощью тега `<constructor-arg value=""/>` в xml-файле передаётся значение в конструктор класса 
  
* ### setter'ы
  с помощью тега `<property name="" ref=""/>` 
  (вместо ссылки может передаваться значение `value = ""`) в xml-файле передаётся значения в сеттеры соответствующих величин

* ### аннотации:
  при помощи аанотаций в коде можно внедрять зависимости и управлять ими.

## Внедрение зависимостей из внешнего файла:
Вместо того чтобы прописывать каждое значение в xml-файле, 
можно создать properties-файл и импортировать значения из него. 
Предварительно, в xml-файле необходимо прописать `<context:property-placeholder location=""/>`.

Scope (Область видимости бинов):
================================

Когда мы определяем bean в Spring Framework, 
у нас есть возможность объявить область видимости этого компонента. 
Настраивается внутри тега `<bean>` при помощи `scope = ""`

* ### singleton

  Определяет один единственный объект бина для каждого контейнера Spring IoC (используется по умолчанию).

* ### prototype

  Создаёт новый объект при каждом вызове. 
  Позволяет иметь любое количество экземпляров бина.

Bean Lifestyle (Жизненный цикл бина)
====================================

При запуске Spring-приложения запускается Spring-контейнер со всеми бинами. 
Создаются объекты бина в соответствии с xml-файлом, 
в бин внедряются зависимости, вызывается **init-method**. 
После того, как пользователь закончит работу с приложением, 
вызывается **destroy-method** и приложение прекращает работу.

Эти методы могут иметь любое название, модификатор доступа, 
тип возвращаемого значения 
(но перехватить его невозможно, так что обычно используют void), 
**но не должны принимать на вход аргументы**.

Фабричный метод (**factory-method**) - паттерн программирования, смысл которого в том,
что программист не сам создаёт объекты через оператор `new`,
а при помощи метода, внутри которого происходит инициализация. При
использовании этого метода, Spring позволяет его указать.

* ### init-method

  Запускается в ходе инициализации бина. 
  Обычно используется для обращения к внешним файлам, 
  запуска БД или инициализации ресурсов. 
  Инициализируется в теге `<bean>` при помощи команды `init-method = ""` и названия нужного метода в классе.
  
* ### destroy-method

  Запускается в ходе уничтожения бина (при завершении приложения). 
  Обычно используется для очищения ресурсов, 
  закрытия потоков или закрытия доступа к БД. 
  Инициализируется в теге `<bean>` при помощи команды `destroy-method = ""` 
  и названия нужного метода в классе. 
  **Не вызывается для бинов с scope = "prototype"**

* ### factory-method
  Используется для реализации паттерна *фабричный метод*. 
  Нужен для настройки процесса создания нового объекта.
  Инициализируется в теге `<bean>` при помощи команды `factory-method = ""`
  и названия нужного метода в классе.
  
Spring-аннотации
================

Spring сканирует все классы, находит в них специальные аннотации
и создаёт бины этих классов и необходимые зависимости.

* ### @Component
  Аннотация для пометки классов, бины которых нужно создать.
  Можно указать **id**, но если не указывать название будет *сМаленькойБуквы*.
  
  В xml-файле необходимо указать директорию для сканирования при помощи 
  `<context:component-scan base-package=""/>`
  
* ### @Autowired
  Аннотация, благодаря которой Spring сам ищет подходящий бин для зависимости 
  и [внедряет](#dependency-injection-внедрение-зависимостей) его. Если не находит ни одного подходящего бина - ошибка.
  Если находит несколько - неоднозначность.
  
  Аннотацию можно использовать к полям, сетторам, конструкторам.

* ### @Qualifier
  Аннотация для выбора нужного бина при неоднозначности `@Autowired`.
  В скобках необходимо указать id приоритетного бина.

  Аннотацию можно использовать к полям, сетторам, конструкторам.

* ### @Value
  Аннотация для выбора значения из properties-файла 

* ### @Scope
  Аннотация для присвоения [области видимости](#scope-область-видимости-бинов) бину.

* ### @PostConstruct
  Аннотация для обозначения метода, как [init-method](#init-method).

* ### @PreDestroy
  Аннотация для обозначения метода, как [destroy-method](#destroy-method).
